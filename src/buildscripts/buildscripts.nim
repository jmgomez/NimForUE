import std/[os, strutils, options, strformat, json, jsonUtils]
import sugar
import system/io
import nimforueconfig
#TODO Move this
func isEmpty*[T](s:seq[T]) : bool = s.len == 0

func tryParseInt*(s:string) : Option[int] =
    try:
      return some(s.parseInt())
    except:
      return none(int)



func getNextFileName*(currentFilename : string) : string = 
  const splitter = "-"
  let (dir, filename, extension) = splitFile(currentFilename)

  let fileSplit = filename.split(splitter)
  if fileSplit.len > 1:
    let num = fileSplit[1].tryParseInt().get(0) + 1
    return &"{fileSplit[0]}{splitter}{num}.{extension}"
  &"{filename}{splitter}1.{extension}"
  


#Example ussage copyFileFromNimCachetoLib("whatever.h", "headers/whatever.h")
proc copyFileFromNimCachetoLib*(filenameSrc:string, filenameDst:string, baserDir="") = 
    
    let fileFullSrc = nimcacheDir() / baserDir / filenameSrc
    echo "NIM CACHE DIR IS " & fileFullSrc
    let libDir = "./"
    let fileFullDest = libDir / filenameDst
    if not fileExists(fileFullSrc):
        echo("ATTENTION: " & fileFullSrc & " does not exists")
        return
    
    rmFile(fileFullDest)
    cpFile(fileFullSrc, fileFullDest)

func getFullLibName(baseLibName:string) :string  = 
    when defined macosx:
        return "lib" & baseLibName & ".dylib"
    when defined windows:
        return  baseLibName & ".dll"
    when defined linux:
        return ""

#This is mostly due to hotreloading. 
#TODO make each platform fit in the correct folder to match unreal conventions
proc copyLibToUE4*(baseLibName:string, nextFileName=baseLibName) = 
    proc tryWithNextFileName() = 
        let nextDllname = getNextFileName(nextFileName)
        echo "next dllname: " & nextDllname
        copyLibToUE4(baseLibName, nextDllname)
      
    var conf = getNimForUEConfig()
    let isNimForUE = "nimforue" in nextFileName and not ("host" in nextFileName)
  
    let libDir = "Binaries"/"nim"
    let libDirUE = libDir / "ue"   

    if not dirExists(libDirUE):
      mkDir(libDirUE)
    var fullLibName : string
    
        
    let baseFullLibName = getFullLibName(baseLibName)
    let nextFullLibName = getFullLibName(nextFileName)
    
    let fileFullSrc = libDir/baseFullLibName
    let fileFullDst = libDirUE/nextFullLibName
    

    try:
        when defined windows:
            rmFile(fileFullDst) #window's way to know if the lib is being used.
          
    except:
        echo fileFullDst & " failed to remove. Retrying with the next filename"
        tryWithNextFileName()
        return

   
    cpFile(fileFullSrc, fileFullDst)
    when defined windows:
      let weakSymbolsLib = baseLibName & ".lib"
      cpFile(libDir/weakSymbolsLib, libDirUE/weakSymbolsLib)
      
    echo fileFullSrc & " copied to " & fileFullDst



proc generateFFIGenFile*() = 
  let genFilePath = getNimForUEConfig().genFilePath
  let content = fmt"""

#AUTOGENERATED FILE. DO NOT EDIT.

import locks
import std/dynlib
import hostbase


"""
  writeFile(genFilePath, content)

proc generateUBTScriptFile*() =
  let pluginDir = getCurrentDir()
  let content = fmt(""" cd {pluginDir} && nimble host""") #only ffi to avoid chicken egg problem
  let filename = if defined Windows: "buildlibs.bat" else: "buildlibs.sh"
  writeFile(pluginDir/"src/buildscripts"/filename, content)
