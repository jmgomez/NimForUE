

import std/[algorithm, options, times, os, osproc, sequtils, 
  strformat, strscans, strutils, sugar, jsonutils, json, enumerate]
import ../nimforue/utils/utils

import buildcommon, nimforueconfig
export buildcommon, nimforueconfig




type #The engine can trigger the load of a library from different places
  NueLoadedFrom* {.size:sizeof(uint8), exportc .} = enum
    nlfDefault = 0, #right after the NimForUEModule is loaded
    nlfPostDefault = 1, #after all modules are loaded (so all the types exists in the reflection system) this is also hot reloads. Should attempt to emit everything, layers before and after
    nlfEditor = 2 # Dont act different as loaded 
    nlfCommandlet = 3 #while on the commandlet. Nothing special. Dont act different as loaded 

proc generateFFIGenFile*(config: NimForUEConfig) = 
  let content = """
#AUTOGENERATED FILE. DO NOT EDIT.

import locks
import std/dynlib
import hostbase
import ../buildscripts/[nimforueconfig, buildscripts]


proc genBindingsEntryPoint*(): void {.exportc, cdecl, dynlib.} =
  type
    ProcType {.inject.} = proc (): void {.cdecl.}
  withLock libLock:
    let fun {.inject.} = cast[ProcType](lib().symAddr("genBindingsEntryPoint"))
    if not fun.isNil():
      fun()

proc reloadScriptGuest*() {.exportc, cdecl, dynlib.} =
  type
    ProcType {.inject.} = proc () {.cdecl.}
  withLock libLock:
    let fun {.inject.} = cast[ProcType](lib().symAddr("reloadScriptGuest"))
    if not fun.isNil():
      fun()

proc onLibLoaded*(libName: cstring; libPath: cstring; timesReloaded: cint;
                  loadedFrom: NueLoadedFrom, libHandle: LibHandle): void {.exportc, cdecl, dynlib.} =
  type
    ProcType {.inject.} = proc (libName: cstring; libPath: cstring;
                                timesReloaded: cint; loadedFrom: NueLoadedFrom, handle: LibHandle): void {.
        cdecl.}
  withLock libLock:
    let fun {.inject.} = cast[ProcType](lib().symAddr("onLibLoaded"))
    if not fun.isNil():
      fun(libName, libPath, timesReloaded, loadedFrom, libHandle)

proc onLoadingPhaseChanged*(prev: NueLoadedFrom; next: NueLoadedFrom): void {.
    exportc, cdecl, dynlib.} =
  type
    ProcType {.inject.} = proc (prev: NueLoadedFrom; next: NueLoadedFrom): void {.
        cdecl.}
  withLock libLock:
    let fun {.inject.} = cast[ProcType](lib().symAddr("onLoadingPhaseChanged"))
    if not fun.isNil():
      fun(prev, next)
"""

  writeFile(GenFilePath, content)


func getNextFileName*(currentFilename : string) : string = 
  const splitter = "-"
  let (_, filename, extension) = splitFile(currentFilename)
  let fileSplit = filename.split(splitter)
  doAssert(fileSplit.len == 1 or fileSplit.len == 2)
  if fileSplit.len == 2:
    let num = fileSplit[1].tryParseInt().get(0) + 1
    return &"{fileSplit[0]}{splitter}{num}{extension}"
  else:
    &"{filename}{splitter}1{extension}"


proc getAllLibsFromPath*(libPath, libName:string) : seq[string] =
  let libName = getFullLibName(libName)
  let libDir = libPath.replace(libName, "")
  let walkPattern = libDir / libName.replace(".", "*.")
  var libs = toSeq(walkFiles(walkPattern))
  let orderByRecent = (a, b : string) => cmp(getLastModificationTime(a), getLastModificationTime(b))
  libs.sorted(orderByRecent, Descending)


proc getLastLibPath*(libPath, libName:string): Option[string] =
  let libs = getAllLibsFromPath(libPath, libName)
  if libs.len == 0:
    return none[string]()
  some libs[0]

const NueExec = when defined(windows): "nue.exe" else: "nue"

proc compileGameSyncFromPlugin*() : string = 
  let (output, _) = execCmdEx(&"{PluginDir}/{NueExec} game")
  output

proc compileGuestSyncFromPlugin*() : string =
  let cmd = &"{PluginDir}/{NueExec} guest --debug"
  let (output, _) = execCmdEx(cmd)
  output

#TODO move from here
type 
  #interal NUE platform target (different than current editor platfrom)
  #it will be used to setup the compiler flags and ultimately generate 
  #a plugin for each platform
  PlatformTargetKind* = enum 
    ptkWindows = "windows"
    ptkLinux = "linux" #Not supported so far
    ptkMac = "macos" #Not supported so far
    ptkIOS = "ios" #Not supported so far
    ptkAndroid = "android" 
    #Add Support to consoles here

proc getPlatformTarget*(arg: string): PlatformTargetKind = 
  let defaultPlatform = 
    when defined(windows): "windows"
    elif defined(macos): "macos"
    else: ""
  if getNimForUEConfig().withEditor or arg == "":
    parseEnum[PlatformTargetKind](defaultPlatform)
  else:
    parseEnum[PlatformTargetKind](arg)

proc getBaseNimCacheDir*(folderName:string, platformTarget: PlatformTargetKind): string =
  &".nimcache/{folderName}/{platformTarget}/"

proc executeNueTask(task: string) =
  let cmd = &"{PluginDir}/{NueExec} {task}"
  let (output, _) = execCmdEx(cmd)
  log output

proc getAllGameLibs*() : seq[string] = 
  var libs = @["game"]
  for dir in walkDir(NimGameDir()):
    let name = dir[1].split(PathSeparator)[^1]
    if fileExists(dir[1] / name & ".nim"):
      libs.add(name)
  libs



proc copyNimForUELibToUEDir*(libName:string) = 
  var conf = getNimForUEConfig()
  let libDir = PluginDir/"Binaries/nim"
  let libDirUE = libDir / "ue"   
  createDir(libDirUE)

  when defined(windows):
    # #deletes previous used ones
    for libPath in getAllLibsFromPath(libDirUE, libName):
      discard tryRemoveFile(libPath) #We just ignore if it fails as it isnt critical to keep going

  let libsCandidates = getAllLibsFromPath(libDirUE, libName)

  proc extractNumber(path: string): int = 
    var ignore : string
    let (_, filename, _) = path.splitFile
    discard scanf(filename, "$*-$i", ignore, result) # ok if no match, number is 0

  let nextLibNumber = if libsCandidates.any():
                        libsCandidates
                          .map(path => extractNumber(path))
                          .max() + 1
                      else:
                        0

  let baseLibName = getFullLibName(libName)
  let nextFileName = getFullLibName(&"{libname}-{nextLibNumber}")

  let fileFullSrc = libDir/baseLibName
  let fileFullDst: string =
    if libsCandidates.isEmpty: #no libs, we just keep the same name
      libDirUE/baseLibName
    else: #more than one lib, we create a new name
      libDirUE/nextFileName

  copyFile(fileFullSrc, fileFullDst)
  log "Copied " & fileFullSrc & " to " & fileFullDst

proc createGameDir*() = 
  createDir(NimGameDir())
  if not fileExists(NimGameDir() / "game.nim"):
    writeFile(NimGameDir() / "game.nim", 
"""
include unrealprelude

uClass AMyNimActor of AActor:
  uprops:
    myInt: int32
  ufuncs(CallInEditor):
    proc myFunc() =
      log "Hello from Nim"
""")

proc getLineNumberFromContent*(content: string, lineContent: string): int = 
  var nLine = -1
  for idx, line in enumerate(content.splitLines()):
    if line.contains(lineContent):
      nLine = idx
      break
  nLine

proc addCompilerOptionsToProject*() = 
  let nueCompilerOptions = """
    bOverrideBuildEnvironment = true;
		if (Target.Platform == UnrealTargetPlatform.Win64) {
			AdditionalCompilerArguments = "/Zc:strictStrings-";
		}
"""
  let lineContent = "ExtraModuleNames.Add"
  let walkPattern = getNimForUEConfig().gameDir / "Source/*.Target.cs"
  for file in walkFiles(walkPattern):
    let fileContent = readFile(file)
    if "strictStrings-" notin fileContent:
      let nLine = getLineNumberFromContent(fileContent, lineContent)
      var lines = fileContent.splitLines()
      lines.insert(nueCompilerOptions, nLine)
      writeFile(file, lines.join("\n"))


proc addNUEPluginToProject*() = 
  var uprojectJson = getGamePathFromGameDir().readFile.parseJson()
  let plugin = newJObject()
  plugin["Name"] = "NimForUE".toJson()
  plugin["Enabled"] = true.toJson()
  
  if uprojectJson["Plugins"].filterIt(it["Name"].getStr == "NimForUE").len == 0:
    uprojectJson["Plugins"].add(plugin)
  
  getGamePathFromGameDir().writeFile(uprojectJson.pretty)